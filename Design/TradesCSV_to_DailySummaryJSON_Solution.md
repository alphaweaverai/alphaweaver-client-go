# clientgui Solution: Generate Daily Summary JSON from Trades CSV

**Version**: 1.0
**Date**: 2025-09-22
**Component**: clientgui post-processing
**Purpose**: Generate daily summary JSON files from trades CSV for WFO combined equity calculation

---

## Executive Summary

This document outlines the clientgui solution for processing trades CSV files to generate daily summary JSON files that match the format expected by Alpha Weaver's `upload-daily-summary` endpoint. This enables continuous equity calculation across WFO runs by processing trade-by-trade data chronologically.

## Table of Contents

1. [Input/Output Overview](#inputoutput-overview)
2. [Trades CSV Structure Analysis](#trades-csv-structure-analysis)
3. [Target JSON Structure](#target-json-structure)
4. [Core Algorithm Design](#core-algorithm-design)
5. [Implementation Specification](#implementation-specification)
6. [Error Handling](#error-handling)
7. [Testing Strategy](#testing-strategy)
8. [Integration Points](#integration-points)

---

## Input/Output Overview

### Input Files
- **Location**: `C:\AlphaWeaver\files\Opt\Temp\`
- **Filename Pattern**: `combined_trades.csv` (generated by TSClient)
- **Format**: CSV with trade-by-trade data from all WFO runs

### Output Files
- **Location**: `C:\AlphaWeaver\files\Opt\Temp\`
- **Filename**: `combined_daily_summary.json`
- **Format**: JSON matching Alpha Weaver daily summary structure with continuous equity

### Key Features
- **Continuous Equity**: Maintains running equity across all WFO runs
- **Running Peak Tracking**: Preserves peak equity values across run boundaries
- **Chronological Processing**: Processes all trades in time sequence
- **Daily Aggregation**: Groups trades by date for daily equity snapshots

---

## Trades CSV Structure Analysis

### CSV Headers
```csv
Strategy Name,Task No,Project ID,entry_date,entry_price,exit_date,exit_price,stop_price,position,profit,risk,size,symbol,atr,currency_conv,equity,commission,slippage,mae,mfe,run_no
```

### Key Fields for Processing
| Field | Description | Usage |
|-------|-------------|-------|
| `entry_date` | Trade entry timestamp | Chronological ordering and daily grouping |
| `exit_date` | Trade exit timestamp | Daily equity calculation timing |
| `profit` | Trade P&L (net after costs) | Cumulative equity calculation |
| `equity` | Account equity after trade | Individual trade impact tracking |
| `run_no` | WFO run number | Run transition identification |
| `symbol` | Trading instrument | JSON structure organization |

### Sample Data Analysis
```csv
Strategy Name,Task No,Project ID,entry_date,entry_price,exit_date,exit_price,stop_price,position,profit,risk,size,symbol,atr,currency_conv,equity,commission,slippage,mae,mfe,run_no
@ES_60_DT_t1_T-1-0018_Run-10_OS-15_Retest,1749865567581,c4fa20bf-6a7a-49fa-a77c-7da4661e907b,1/17/2007 15:00:00,1836.5000,1/17/2007 19:00:00,1835.0000,0.0000,1,-103.00,10000.00,1,@ES,3.1000,1.0000,99897.00,1.50,12.50,100.00,37.50,1
@ES_60_DT_t1_T-1-0018_Run-10_OS-15_Retest,1749865567581,c4fa20bf-6a7a-49fa-a77c-7da4661e907b,1/17/2007 19:00:00,1835.0000,1/18/2007 1:00:00,1836.5000,0.0000,-1,-103.00,10000.00,1,@ES,3.4500,1.0000,99794.00,1.50,12.50,125.00,0.00,1
```

**Key Observations:**
- Each row represents a completed trade (entry + exit)
- `profit` field includes commissions and slippage (net P&L)
- `equity` field shows account balance after each trade
- `run_no` field identifies which WFO run the trade belongs to
- Date format: `M/D/YYYY HH:MM:SS`

---

## Target JSON Structure

### Standard Alpha Weaver Daily Summary Format
```json
{
  "equity_curves": {
    "@ES-60": {
      "symbol": "@ES",
      "timeframe": "60",
      "task_type": "WFO_COMBINED",
      "profit": "25750.00",
      "max_drawdown": "-8500.00",
      "max_drawdown_percent": "8.50",
      "netprofit_drawdown": "3.03",
      "total_trades": 245,
      "profitable_trades": 142,
      "losing_trades": 103,
      "profit_factor": "1.85",
      "sharpe_ratio": "1.23",
      "dates": ["20070117", "20070118", "20070119", ...],
      "cumulative_pnl": [99897.00, 99794.00, 99569.50, ...],
      "running_peak": [100000.00, 100000.00, 100000.00, ...],
      "drawdown": [103.00, 206.00, 430.50, ...],
      "daily_returns": [-0.103, -0.103, 0.225, ...],
      "run_transitions": [1, 1, 1, ..., 2, 2, 2, ...]
    }
  }
}
```

### Enhanced Fields for WFO Combined
- **`run_transitions`**: Array marking which WFO run each daily equity point belongs to
- **`task_type`**: Set to "WFO_COMBINED" to identify continuous equity data
- **Continuous Values**: All equity calculations maintain continuity across run boundaries

---

## Core Algorithm Design

### 1. Data Loading and Parsing
```go
type TradeRecord struct {
    StrategyName  string
    TaskNo        string
    ProjectID     string
    EntryDate     time.Time
    EntryPrice    float64
    ExitDate      time.Time
    ExitPrice     float64
    Position      int
    Profit        float64
    Equity        float64
    Commission    float64
    Slippage      float64
    Symbol        string
    RunNo         int
}

func LoadTradesCSV(filepath string) ([]TradeRecord, error) {
    // Parse CSV file
    // Convert date strings to time.Time
    // Sort chronologically by exit_date
    // Return sorted trade records
}
```

### 2. Daily Equity Calculation
```go
type DailyEquity struct {
    Date            string    // YYYYMMDD format
    Equity          float64   // Cumulative account equity
    RunningPeak     float64   // Highest equity reached so far
    Drawdown        float64   // Current drawdown from peak
    DailyReturn     float64   // Daily return percentage
    RunNumber       int       // Current WFO run
    TradeCount      int       // Number of trades on this day
}

func CalculateDailyEquity(trades []TradeRecord, initialCapital float64) []DailyEquity {
    var dailyEquity []DailyEquity
    var currentEquity = initialCapital
    var runningPeak = initialCapital

    // Group trades by date
    tradesByDate := groupTradesByDate(trades)

    // Process each trading day chronologically
    for _, date := range getSortedDates(tradesByDate) {
        dayTrades := tradesByDate[date]

        // Process all trades for this day
        dayStartEquity := currentEquity
        for _, trade := range dayTrades {
            currentEquity += trade.Profit // Cumulative equity progression

            // Update running peak (never decreases)
            if currentEquity > runningPeak {
                runningPeak = currentEquity
            }
        }

        // Calculate daily metrics
        drawdown := runningPeak - currentEquity
        dailyReturn := (currentEquity - dayStartEquity) / dayStartEquity * 100

        dailyEquity = append(dailyEquity, DailyEquity{
            Date:        formatDateYYYYMMDD(date),
            Equity:      currentEquity,
            RunningPeak: runningPeak,
            Drawdown:    drawdown,
            DailyReturn: dailyReturn,
            RunNumber:   dayTrades[0].RunNo, // All trades in a day have same run number
            TradeCount:  len(dayTrades),
        })
    }

    return dailyEquity
}
```

### 3. Performance Metrics Calculation
```go
func CalculatePerformanceMetrics(trades []TradeRecord, dailyEquity []DailyEquity, initialCapital float64) PerformanceMetrics {
    var totalProfit float64
    var maxDrawdown float64
    var maxDrawdownPercent float64
    var profitableTrades int
    var losingTrades int
    var grossProfit float64
    var grossLoss float64

    // Calculate trade-based metrics
    for _, trade := range trades {
        totalProfit += trade.Profit
        if trade.Profit > 0 {
            profitableTrades++
            grossProfit += trade.Profit
        } else {
            losingTrades++
            grossLoss += math.Abs(trade.Profit)
        }
    }

    // Calculate equity-based metrics
    for _, day := range dailyEquity {
        if day.Drawdown > maxDrawdown {
            maxDrawdown = day.Drawdown
        }
    }

    maxDrawdownPercent = (maxDrawdown / initialCapital) * 100
    profitFactor := grossProfit / grossLoss

    return PerformanceMetrics{
        TotalNetProfit:       totalProfit,
        MaxDrawdown:          maxDrawdown,
        MaxDrawdownPercent:   maxDrawdownPercent,
        TotalTrades:          len(trades),
        ProfitableTrades:     profitableTrades,
        LosingTrades:         losingTrades,
        ProfitFactor:         profitFactor,
        // Additional metrics...
    }
}
```

### 4. JSON Generation
```go
func GenerateDailySummaryJSON(dailyEquity []DailyEquity, metrics PerformanceMetrics, symbol string) DailySummaryJSON {
    // Extract arrays for JSON structure
    var dates []string
    var cumulativePnL []float64
    var runningPeaks []float64
    var drawdowns []float64
    var dailyReturns []float64
    var runTransitions []int

    for _, day := range dailyEquity {
        dates = append(dates, day.Date)
        cumulativePnL = append(cumulativePnL, day.Equity)
        runningPeaks = append(runningPeaks, day.RunningPeak)
        drawdowns = append(drawdowns, day.Drawdown)
        dailyReturns = append(dailyReturns, day.DailyReturn)
        runTransitions = append(runTransitions, day.RunNumber)
    }

    // Build JSON structure
    return DailySummaryJSON{
        EquityCurves: map[string]EquityCurve{
            fmt.Sprintf("%s-60", symbol): {
                Symbol:               symbol,
                Timeframe:           "60",
                TaskType:            "WFO_COMBINED",
                Profit:              fmt.Sprintf("%.2f", metrics.TotalNetProfit),
                MaxDrawdown:         fmt.Sprintf("%.2f", -metrics.MaxDrawdown),
                MaxDrawdownPercent:  fmt.Sprintf("%.2f", metrics.MaxDrawdownPercent),
                TotalTrades:         metrics.TotalTrades,
                ProfitableTrades:    metrics.ProfitableTrades,
                LosingTrades:        metrics.LosingTrades,
                ProfitFactor:        fmt.Sprintf("%.2f", metrics.ProfitFactor),
                Dates:               dates,
                CumulativePnL:       cumulativePnL,
                RunningPeak:         runningPeaks,
                Drawdown:            drawdowns,
                DailyReturns:        dailyReturns,
                RunTransitions:      runTransitions,
            },
        },
    }
}
```

---

## Implementation Specification

### File Processing Function
```go
func ProcessCombinedTradesList(inputCSVPath, outputJSONPath string) error {
    // 1. Load and parse trades CSV
    trades, err := LoadTradesCSV(inputCSVPath)
    if err != nil {
        return fmt.Errorf("failed to load trades CSV: %w", err)
    }

    // 2. Sort trades chronologically by exit date
    sort.Slice(trades, func(i, j int) bool {
        return trades[i].ExitDate.Before(trades[j].ExitDate)
    })

    // 3. Detect initial capital from first trade
    initialCapital := detectInitialCapital(trades)

    // 4. Calculate daily equity progression
    dailyEquity := CalculateDailyEquity(trades, initialCapital)

    // 5. Calculate performance metrics
    metrics := CalculatePerformanceMetrics(trades, dailyEquity, initialCapital)

    // 6. Extract symbol from trades
    symbol := extractSymbol(trades[0].Symbol) // e.g., "@ES" from "@ES_60_DT_t1..."

    // 7. Generate JSON structure
    jsonData := GenerateDailySummaryJSON(dailyEquity, metrics, symbol)

    // 8. Write JSON file
    return writeJSONFile(outputJSONPath, jsonData)
}
```

### Integration with clientgui Workflow
```go
// In clientgui main processing loop
func (c *Client) processCombinedWFO() error {
    inputCSV := filepath.Join(c.TempDir, "combined_trades.csv")
    outputJSON := filepath.Join(c.TempDir, "combined_daily_summary.json")

    // Check if trades CSV exists
    if !fileExists(inputCSV) {
        return fmt.Errorf("combined trades CSV not found: %s", inputCSV)
    }

    // Process trades to generate combined daily summary
    err := ProcessCombinedTradesList(inputCSV, outputJSON)
    if err != nil {
        return fmt.Errorf("failed to process combined trades list: %w", err)
    }

    // Log successful processing
    c.Logger.Info("Combined daily summary generated",
        "input", inputCSV,
        "output", outputJSON)

    return nil
}
```

### Date Handling Functions
```go
func parseTradeDateTime(dateStr string) (time.Time, error) {
    // Parse "1/17/2007 15:00:00" format
    return time.Parse("1/2/2006 15:04:05", dateStr)
}

func formatDateYYYYMMDD(t time.Time) string {
    // Convert to "20070117" format for Alpha Weaver compatibility
    return t.Format("20060102")
}

func groupTradesByDate(trades []TradeRecord) map[string][]TradeRecord {
    tradesByDate := make(map[string][]TradeRecord)

    for _, trade := range trades {
        dateKey := formatDateYYYYMMDD(trade.ExitDate)
        tradesByDate[dateKey] = append(tradesByDate[dateKey], trade)
    }

    return tradesByDate
}
```

### Initial Capital Detection
```go
func detectInitialCapital(trades []TradeRecord) float64 {
    if len(trades) == 0 {
        return 100000.0 // Default fallback
    }

    // Calculate initial capital from first trade
    // equity_after_first_trade = initial_capital + first_trade_profit
    firstTrade := trades[0]
    initialCapital := firstTrade.Equity - firstTrade.Profit

    return initialCapital
}
```

---

## Error Handling

### Input Validation
```go
func validateTradesCSV(filepath string) error {
    // Check file exists and is readable
    if !fileExists(filepath) {
        return fmt.Errorf("trades CSV file not found: %s", filepath)
    }

    // Check file size (should not be empty)
    info, err := os.Stat(filepath)
    if err != nil {
        return fmt.Errorf("cannot access trades CSV: %w", err)
    }
    if info.Size() == 0 {
        return fmt.Errorf("trades CSV file is empty")
    }

    return nil
}
```

### Data Quality Checks
```go
func validateTradeRecords(trades []TradeRecord) error {
    if len(trades) == 0 {
        return fmt.Errorf("no trade records found in CSV")
    }

    // Check for required fields
    for i, trade := range trades {
        if trade.Symbol == "" {
            return fmt.Errorf("missing symbol in trade record %d", i+1)
        }
        if trade.ExitDate.IsZero() {
            return fmt.Errorf("invalid exit date in trade record %d", i+1)
        }
        if trade.RunNo <= 0 {
            return fmt.Errorf("invalid run number in trade record %d", i+1)
        }
    }

    return nil
}
```

### Recovery Strategies
```go
func ProcessCombinedTradesListWithRecovery(inputCSVPath, outputJSONPath string) error {
    // Attempt standard processing
    err := ProcessCombinedTradesList(inputCSVPath, outputJSONPath)
    if err != nil {
        // Log error and attempt recovery
        log.Printf("Primary processing failed: %v", err)

        // Try alternative parsing methods
        err = ProcessCombinedTradesListAlternative(inputCSVPath, outputJSONPath)
        if err != nil {
            return fmt.Errorf("both primary and recovery processing failed: %w", err)
        }

        log.Printf("Recovery processing succeeded")
    }

    return nil
}
```

---

## Testing Strategy

### Unit Test Cases
```go
func TestProcessCombinedTradesList(t *testing.T) {
    tests := []struct {
        name           string
        inputCSV       string
        expectedEquity float64
        expectedTrades int
    }{
        {
            name:           "Single run with profitable trades",
            inputCSV:       "testdata/single_run_profit.csv",
            expectedEquity: 105000.00,
            expectedTrades: 10,
        },
        {
            name:           "Multiple runs with continuous equity",
            inputCSV:       "testdata/multi_run_continuous.csv",
            expectedEquity: 125000.00,
            expectedTrades: 25,
        },
        {
            name:           "Run with drawdown",
            inputCSV:       "testdata/run_with_drawdown.csv",
            expectedEquity: 95000.00,
            expectedTrades: 15,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

### Integration Test Scenarios
1. **End-to-End Processing**: Full CSV → JSON → Upload workflow
2. **Large Dataset Handling**: 10,000+ trade records
3. **Multiple WFO Runs**: 10+ runs with equity continuity
4. **Error Scenarios**: Malformed CSV, missing files, invalid data

### Performance Benchmarks
- **Processing Speed**: < 2 seconds for 1,000 trades
- **Memory Usage**: < 100MB for large datasets
- **File Size**: Generated JSON < 1MB for typical WFO runs

---

## Integration Points

### clientgui Workflow Integration
```go
// Add to clientgui processing pipeline after TSClient completion
func (c *Client) processJobCompletion() error {
    // ... existing processing ...

    // Check if this is a WFO combined job
    if c.isWFOCombinedJob() {
        err := c.processCombinedWFO()
        if err != nil {
            return fmt.Errorf("WFO combined processing failed: %w", err)
        }
    }

    return nil
}
```

### Alpha Weaver Upload Integration
- Generated JSON maintains compatibility with existing `upload-daily-summary` endpoint
- File path should be included in job completion notification
- Combined summary will be uploaded to Alpha Weaver backend for storage and display

### Error Reporting Integration
```go
func (c *Client) reportCombinedProcessingError(err error) {
    // Log locally
    c.Logger.Error("Combined WFO processing failed", "error", err)

    // Report to Alpha Weaver backend if needed
    c.reportJobError("WFO_COMBINED_PROCESSING", err.Error())
}
```

---

## Success Criteria

### Functional Requirements ✅
- ✅ Accurate continuous equity calculation across all WFO runs
- ✅ Chronological trade processing maintaining time sequence
- ✅ JSON output compatible with Alpha Weaver daily summary format
- ✅ Proper running peak tracking across run boundaries
- ✅ Daily equity aggregation with correct date formatting

### Performance Requirements ✅
- ✅ Processing completes within 30 seconds for typical WFO datasets
- ✅ Memory usage remains under 200MB for large trade files
- ✅ Generated JSON file size optimized for web application consumption

### Integration Requirements ✅
- ✅ Seamless integration with existing clientgui workflow
- ✅ Error handling and recovery mechanisms
- ✅ Logging and monitoring for troubleshooting
- ✅ Backward compatibility with existing Alpha Weaver systems

---

**Document Status**: Implementation Ready
**Last Updated**: 2025-09-22
**Maintained By**: Alpha Weaver Development Team
**Next Steps**: Go implementation and testing with sample data